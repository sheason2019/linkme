# v0.0.2

# 需求描述

v0.0.2 的主要目标是开发待办事项功能。

开发待办事项的主要目的是为 Linkme 提供个人的工作进程展示能力，以起到自我督促和展示工作进度时间线的作用。

# 必要性描述

在人们通常所设计的 TODO 事项中，TODO 总是以列表的形式出现，人们完成一件事，然后去找下一件事情进行完成，几乎所有 TODO 应用，都在采取这种理想化的模型。

但事实上，用队列来思考待办事项这个模型，在现实生活中是完全不够用的。在面对实际生活中遇到的问题时，我们往往需要使用自顶向下的思考方式，将一个整体而困难的事情分解成小而无序的事情，而在某些极端的情况下，这些事情还会被进一步细分，使用传统的队列模式要怎么去管理好这些复杂的难题？这其实是一个很大的难题。

而解决这个问题的最好方式，是转换我们的思维方式，用图作为数据结构去思考 TODO 应用的模型，把它所承载的每个任务当成彼此之间可以互相引用、依赖的单元，通过这种方式，我们可以更好的去分解问题、组织问题再集成问题，从而使自己能更轻松明确的编排自己的工作节奏。

同时，有些 Todo 应用中忽略了“提交”这个概念的重要性。现在，我们可以先思考一下 Todo 存在的意义是什么？对大多数使用 Todo 的人来说，Todo 的意义不仅仅只是一个能让自己的行动更有条理的备忘录，它实际上是一个能帮助你分解事件，并在你有序完成事件是能不停通过点击完成按钮来提供积极反馈的行动激励器。既然如此，为什么我们不更进一步，让它拥有能激发人类延迟满足感的能力呢？

想象一下，把你的 Todo 应用当成一个 Git Repo，每当你完成一个阶段的任务后（比如完成了某一天预定好的行程），你都可以通过一次“提交”，将你这一阶段所完成的事项记录成一个未来随时都可以查看的快照。

如果你持续工作的时间够长，这些无穷无尽的快照就能逐渐拼凑出你个人成长的漫长旅途，供你在闲暇时进行回忆，或是分享给他人，邀请别人一起见证你的成长。

总而言之，我们可以在市面现有 Todo 应用的基础上，赋予 Todo 应用更强的功能和更深入的意义。

# 可行性描述

这个需求里的难点粗略可以分为以下两个部分：

- 图结构事项

- 快照的实现

## 图结构事项

图在数据结构里属于心智负担相对比较大的一种结构类型，把图转换到关系型数据库里的过程也可能比较让人头大，所以，在构建图结构事项模型的时候，如果结合需求来理解，可能会稍微简单的一点，一个简单的事项 Model 如下所示：

```go
type TodoItem struct {
  gorm.Model
  // 这是任务事项的内容
  Title string
  // 引用了该任务事项的任务事项
  References []TodoItem
  // 该任务事项所引用的任务事项
  Contained []TodoItem
  // 任务事项所引用的事项的排序关系，是一个 []int 字符串
  Index string
  // 待办事项状态 Waiting Finished Commited
  Status string

  SeriesId uint
}
```

可以看到，任务事项通过 References 和 Contained 两个属性，完成了对自身的复杂引用，从而构建出了系统内复杂的待办事项图。

而仅有这个图，我们是无法将用户定义的待办事项展示到他们面前的，因为图是一个无头的结构，如果不遵照某种规则，我们就无法将这个结构内囊括的内容呈现给用户，因此，我们需要定义一个能索引出图内容的概念——组。

```go
type TodoGroup struct {
  gorm.Model
  // 组名
  Name string
  // 组内拥有的任务事项
  Contained []TodoItem
  // 排序同样使用 []int 字符串
  Index string
  // 系列ID，后面会讲到这个概念
  SeriesId uint
}
```

通过 TodoGroup 的概念，我们就可以为用户创建分组，同时在分组中为用户整体的待办事项 Map 创建索引头。

待办事项是一个需要需要频繁进行增删改查的应用，增改这两块由于相对比较简单，当模型被建立以后，在图里增加数据和修改数据的方式就已经可以初步确定了；而查询这方面，我们通过定义一个 TodoGroup 为用户按分组创建指定的图索引，使用户拥有了通过索引获取图数据的能力；但删除呢？

这是整个应用中所面临的最难的挑战，整个 Todo 应用中的图数据的依赖关系来回交错，它们之中的某些任务事项甚至会作为父任务事项所定义的匿名事项仅存在于父任务事项的引用中，如果我们在某一刻需要对父任务事项进行删除，那么这些随着父任务事项被删除的、再也无法被引用的事项应该怎么办？

没错，它们当然也应该被一并移除。所以，我们在执行删除逻辑的时候，除了删除指定的任务事项外，还应该遍历拿到它所引用的所有任务子项以及子项的相关依赖，并使用标记清理法将所有再也无法被索引到的子项一并删除。

这个逻辑非常复杂，所以，我们必须为能够互相影响的待办事项设定一个边界，以控制计算量。

而这个边界的名字就叫做 Series（系列）。

```go
type TodoSeries struct {
  gorm.Model
  Name string

  // 边界的所有者ID
  OwnerId uint
}
```

只有在同一个系列中的 TodoItem 才能被互相引用，通过创建这样的强边界，我们可以大幅降低标记清理法的工作量，尽管它仍然是一个复杂的逻辑，但如果我们能通过这种方式有效地将运算涉及的数据量控制在一个合理的区间，用户就不会感受到因复杂逻辑而带来的卡顿。

在完成数据建模之后，我们实际上还有一个功能需要实现，那就是 Commit 功能。Commit 功能的概念是什么呢？简单概括就是将指定系列下，所有被标记为完成的事项调整为只读状态。被调整为只读状态的事项无法再进行任何修改，无论是依赖、被依赖关系，还是事项所包含的内容，都不会再发生任何变化。

同时，服务端会在数据库中根据提交的内容生成一个用来在前端展示 Diff 内容的快照，让用户可以方便的回览自己在某一天的工作进程。

根据这些需求，我们可以很轻松的构建出一个 Commit 的模型：

```go
type TodoCommit struct {
  gorm.Model
  // 对Commit的描述
  Describe string
  // 快照信息
  Snapshot string
  // 所属的Series
  SeriesId uint
}
```

以图结构为核心的待办事项，和 Commit 机制，就是第一期待办事项开发的主要内容。

# 需求排期

保守估计的话这个需求应该同样是两周左右的时间可以完成，具体的日期是 2022/12/06 ~ 2022/12/20。
